# Tutorial: Unit 6.1 — Generative Art with Canvas

**Module:** 06 — Creative Web Projects  
**Unit:** 6.1 — Generative Art  
**Duration:** 90–120 minutes  
**Prerequisites:** Modules 01–04, Module 05 recommended (Canvas basics)

---

## Overview

In this unit, you will learn to create **generative art**—visual compositions generated by code using rules, randomness, and repetition. You'll use HTML5 Canvas to draw parameterized patterns, implement animation loops, and build user interfaces (sliders, buttons) to control your artwork in real time.

**What You'll Build:**

A generative art piece featuring:

- **Parameterized shapes:** Size, color, rotation controlled by variables
- **Animation loop:** Shapes continuously redraw with variations
- **User controls:** Sliders and buttons to adjust parameters live
- **Creative expression:** Your unique visual style

**Learning Outcomes:**

By the end of this unit, you will be able to:

1. Use `requestAnimationFrame()` for smooth animation loops
2. Generate random values within ranges for visual variety
3. Parameterize visual properties (size, color, position, rotation)
4. Create UI controls (sliders, inputs) linked to visual parameters
5. Apply transformations (translate, rotate, scale) on Canvas
6. Combine repetition, randomness, and rules to create emergent patterns
7. Explain generative art concepts and your creative decisions

---

## What is Generative Art?

**Generative art** is created using autonomous systems—code that follows rules, incorporates randomness, and produces visual output.

**Key Characteristics:**

- **Algorithmic:** Created by code, not by hand
- **Parameterized:** Adjustable variables control the outcome
- **Emergent:** Complex patterns emerge from simple rules
- **Unique:** Each run can produce different results (via randomness)

**Examples:**

- Geometric patterns (spirals, grids, fractals)
- Particle systems (simulating natural phenomena)
- Procedural textures (noise-based visuals)
- Interactive visualizations (responding to user input)

**Artists:**

- **Vera Molnár:** Early computer art pioneer (plotter drawings)
- **John Maeda:** Design by Numbers, computational design
- **Casey Reas & Ben Fry:** Processing (creative coding framework)
- **Joshua Davis:** Generative design and data-driven art

---

## Step 1: Canvas Setup for Animation

### HTML Structure

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Generative Art — Unit 6.1</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: #f0f0f0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      h1 {
        margin: 0 0 10px;
        font-size: 24px;
      }
      #canvas-container {
        background: white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      canvas {
        display: block;
      }
      #controls {
        background: white;
        padding: 20px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        max-width: 800px;
      }
      .control-group {
        margin-bottom: 15px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input[type="range"] {
        width: 100%;
      }
      .value-display {
        display: inline-block;
        margin-left: 10px;
        color: #666;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-right: 10px;
      }
      button:hover {
        background: #0056b3;
      }
    </style>
  </head>
  <body>
    <h1>Generative Art: Animated Circles</h1>

    <div id="canvas-container">
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <div id="controls">
      <div class="control-group">
        <label for="circle-count"
          >Circle Count:
          <span id="count-value" class="value-display">50</span></label
        >
        <input type="range" id="circle-count" min="10" max="200" value="50" />
      </div>

      <div class="control-group">
        <label for="circle-size"
          >Circle Size:
          <span id="size-value" class="value-display">20</span></label
        >
        <input type="range" id="circle-size" min="5" max="100" value="20" />
      </div>

      <div class="control-group">
        <label for="animation-speed"
          >Animation Speed:
          <span id="speed-value" class="value-display">1</span></label
        >
        <input
          type="range"
          id="animation-speed"
          min="0.1"
          max="5"
          step="0.1"
          value="1"
        />
      </div>

      <div class="control-group">
        <button id="pause-btn">Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="save-btn">Save Image</button>
      </div>
    </div>

    <script src="script.js"></script>
  </body>
</html>
```

### JavaScript: Basic Animation Loop

Create `script.js`:

```javascript
// Get canvas and context
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// Parameters (will be controlled by UI)
let circleCount = 50;
let circleSize = 20;
let animationSpeed = 1;
let isPaused = false;

// Animation state
let frame = 0;

// Animation loop
function animate() {
  if (!isPaused) {
    // Clear canvas
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw generative pattern
    drawPattern();

    // Increment frame counter
    frame += animationSpeed;
  }

  // Request next frame
  requestAnimationFrame(animate);
}

// Placeholder drawing function
function drawPattern() {
  ctx.fillStyle = "steelblue";
  ctx.fillRect(50, 50, 100, 100);
}

// Start animation
animate();
```

**Key Concepts:**

- **`requestAnimationFrame()`:** Browser-optimized animation method. Calls function before next repaint (~60 FPS).
- **Animation loop:** Continuously clears and redraws canvas.
- **Frame counter:** Tracks time progression for animations.
- **Semi-transparent fill:** Creates "trail" effect by not fully clearing canvas.

---

## Step 2: Random Values and Variation

### Generating Random Numbers

```javascript
// Random integer between min and max (inclusive)
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Random float between min and max
function randomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

// Random color (hex)
function randomColor() {
  const letters = "0123456789ABCDEF";
  let color = "#";
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

// Random color (HSL for better control)
function randomHSL(hueMin = 0, hueMax = 360, saturation = 70, lightness = 50) {
  const hue = randomInt(hueMin, hueMax);
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
```

**Usage:**

```javascript
const x = randomInt(0, canvas.width);
const y = randomInt(0, canvas.height);
const radius = randomFloat(5, 30);
const color = randomHSL(200, 240); // Blue range

ctx.fillStyle = color;
ctx.beginPath();
ctx.arc(x, y, radius, 0, Math.PI * 2);
ctx.fill();
```

**Why HSL?**

- **Hue:** 0–360 (color wheel: 0 = red, 120 = green, 240 = blue)
- **Saturation:** 0–100 (0 = gray, 100 = vivid)
- **Lightness:** 0–100 (0 = black, 50 = pure color, 100 = white)

HSL allows controlled color palettes (e.g., "blue range" or "warm tones").

---

## Step 3: Parameterized Drawing — Circles Pattern

### Drawing Circles with Parameters

Replace `drawPattern()` with:

```javascript
function drawPattern() {
  for (let i = 0; i < circleCount; i++) {
    // Use frame for animation
    const angle = (i / circleCount) * Math.PI * 2 + frame * 0.01;

    // Position on circular path
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const orbitRadius = 200;
    const x = centerX + Math.cos(angle) * orbitRadius;
    const y = centerY + Math.sin(angle) * orbitRadius;

    // Size variation
    const size = circleSize + Math.sin(frame * 0.05 + i) * 10;

    // Color based on position
    const hue = (i / circleCount) * 360;
    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;

    // Draw circle
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}
```

**Explanation:**

- **Circular arrangement:** Circles positioned in ring using trigonometry
  - `angle = (i / circleCount) * 2π` distributes circles evenly
  - `x = centerX + cos(angle) × radius`
  - `y = centerY + sin(angle) × radius`
- **Animation:** `+ frame * 0.01` rotates pattern over time
- **Size variation:** `Math.sin(frame * 0.05 + i) * 10` creates pulsing effect
- **Color gradient:** Hue varies from 0–360 (full rainbow)

**Trigonometry Refresher:**

```
       y
       │
   ────┼──── x
       │

For angle θ and radius r:
x = centerX + cos(θ) × r
y = centerY + sin(θ) × r
```

---

## Step 4: Canvas Transformations

### Translation, Rotation, Scale

```javascript
function drawRotatedRect(x, y, width, height, angle, color) {
  ctx.save(); // Save current state

  // Move origin to shape center
  ctx.translate(x, y);

  // Rotate around new origin
  ctx.rotate(angle);

  // Draw centered rectangle
  ctx.fillStyle = color;
  ctx.fillRect(-width / 2, -height / 2, width, height);

  ctx.restore(); // Restore state
}

// Usage
drawRotatedRect(400, 300, 50, 100, frame * 0.02, "steelblue");
```

**Key Methods:**

- **`ctx.save()`:** Push current transformation state onto stack
- **`ctx.translate(x, y)`:** Move origin to new position
- **`ctx.rotate(angle)`:** Rotate coordinate system (radians)
- **`ctx.scale(sx, sy)`:** Scale coordinate system
- **`ctx.restore()`:** Pop state from stack (undo transformations)

**Why save/restore?**

Transformations affect all subsequent drawing. Save/restore isolates transformations to specific shapes.

---

## Step 5: Advanced Pattern — Spirograph

### Spirograph Algorithm

```javascript
function drawSpirograph() {
  ctx.strokeStyle = "rgba(100, 100, 255, 0.5)";
  ctx.lineWidth = 2;
  ctx.beginPath();

  const R = 150; // Fixed circle radius
  const r = 50; // Rolling circle radius
  const O = 80; // Distance from rolling circle center

  let firstPoint = true;

  for (let t = 0; t < Math.PI * 2 * 100; t += 0.01) {
    // Spirograph parametric equations
    const x = (R - r) * Math.cos(t) + O * Math.cos(((R - r) / r) * t);
    const y = (R - r) * Math.sin(t) - O * Math.sin(((R - r) / r) * t);

    // Center on canvas
    const canvasX = canvas.width / 2 + x;
    const canvasY = canvas.height / 2 + y;

    if (firstPoint) {
      ctx.moveTo(canvasX, canvasY);
      firstPoint = false;
    } else {
      ctx.lineTo(canvasX, canvasY);
    }
  }

  ctx.stroke();
}
```

**Parametric Equations:**

Spirograph traces path of a point on a circle rolling inside/outside another circle:

```
x = (R - r) × cos(t) + O × cos(((R - r) / r) × t)
y = (R - r) × sin(t) - O × sin(((R - r) / r) × t)
```

- **R:** Fixed circle radius
- **r:** Rolling circle radius
- **O:** Distance of point from rolling circle center
- **t:** Parameter (0 to 2π × iterations)

**Variations:**

- Change R, r, O values
- Use `(R + r)` for epitrochoid (rolling outside)
- Animate by varying parameters with frame

---

## Step 6: UI Controls — Linking Sliders to Parameters

### Connecting Sliders

```javascript
// Get UI elements
const circleCountSlider = document.getElementById("circle-count");
const circleSizeSlider = document.getElementById("circle-size");
const animationSpeedSlider = document.getElementById("animation-speed");

const countValue = document.getElementById("count-value");
const sizeValue = document.getElementById("size-value");
const speedValue = document.getElementById("speed-value");

// Update parameters when sliders change
circleCountSlider.addEventListener("input", (e) => {
  circleCount = parseInt(e.target.value);
  countValue.textContent = circleCount;
});

circleSizeSlider.addEventListener("input", (e) => {
  circleSize = parseInt(e.target.value);
  sizeValue.textContent = circleSize;
});

animationSpeedSlider.addEventListener("input", (e) => {
  animationSpeed = parseFloat(e.target.value);
  speedValue.textContent = animationSpeed.toFixed(1);
});

// Pause/Resume button
const pauseBtn = document.getElementById("pause-btn");
pauseBtn.addEventListener("click", () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
});

// Reset button
const resetBtn = document.getElementById("reset-btn");
resetBtn.addEventListener("click", () => {
  frame = 0;
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
});

// Save image button
const saveBtn = document.getElementById("save-btn");
saveBtn.addEventListener("click", () => {
  const link = document.createElement("a");
  link.download = "generative-art.png";
  link.href = canvas.toDataURL();
  link.click();
});
```

**Key Points:**

- **`input` event:** Fires while dragging slider (real-time updates)
- **`parseInt` / `parseFloat`:** Convert string values to numbers
- **`canvas.toDataURL()`:** Exports canvas as PNG data URL

---

## Step 7: Complete Example — Particle System

### Particle Class

```javascript
class Particle {
  constructor() {
    this.x = randomFloat(0, canvas.width);
    this.y = randomFloat(0, canvas.height);
    this.vx = randomFloat(-2, 2);
    this.vy = randomFloat(-2, 2);
    this.radius = randomFloat(2, 8);
    this.hue = randomInt(0, 360);
    this.alpha = randomFloat(0.3, 1);
  }

  update() {
    // Move particle
    this.x += this.vx * animationSpeed;
    this.y += this.vy * animationSpeed;

    // Wrap around edges
    if (this.x < 0) this.x = canvas.width;
    if (this.x > canvas.width) this.x = 0;
    if (this.y < 0) this.y = canvas.height;
    if (this.y > canvas.height) this.y = 0;
  }

  draw() {
    ctx.fillStyle = `hsla(${this.hue}, 70%, 50%, ${this.alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Create particles array
let particles = [];
function initParticles() {
  particles = [];
  for (let i = 0; i < circleCount; i++) {
    particles.push(new Particle());
  }
}
initParticles();

// Update drawing function
function drawPattern() {
  particles.forEach((particle) => {
    particle.update();
    particle.draw();
  });
}

// Reinitialize particles when count changes
circleCountSlider.addEventListener("input", (e) => {
  circleCount = parseInt(e.target.value);
  countValue.textContent = circleCount;
  initParticles();
});
```

**Explanation:**

- **Particle class:** Encapsulates position, velocity, appearance
- **`update()`:** Moves particle, wraps around edges
- **`draw()`:** Renders particle
- **Wrap-around:** Creates infinite looping effect

**Extensions:**

- Add acceleration and friction (physics)
- Connect nearby particles with lines (constellation effect)
- Add mouse interaction (particles avoid/follow cursor)
- Implement collision detection

---

## Step 8: Creative Variations

### Variation 1: Geometric Grid

```javascript
function drawGeometricGrid() {
  const gridSize = 50;
  const cols = Math.ceil(canvas.width / gridSize);
  const rows = Math.ceil(canvas.height / gridSize);

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      const x = i * gridSize + gridSize / 2;
      const y = j * gridSize + gridSize / 2;

      // Rotation based on position and time
      const angle = (i + j) * 0.5 + frame * 0.02;

      // Color based on position
      const hue = (i / cols) * 180 + 200;

      drawRotatedRect(
        x,
        y,
        gridSize * 0.8,
        gridSize * 0.8,
        angle,
        `hsl(${hue}, 60%, 50%)`
      );
    }
  }
}
```

### Variation 2: Noise-Based Lines

```javascript
// Simple 1D noise (for demo; use library like simplex-noise for real projects)
function noise(x) {
  return Math.sin(x * 0.1) * 0.5 + Math.cos(x * 0.05) * 0.5;
}

function drawNoisyLines() {
  const lineCount = 20;
  const spacing = canvas.height / lineCount;

  ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
  ctx.lineWidth = 2;

  for (let i = 0; i < lineCount; i++) {
    ctx.beginPath();
    const baseY = i * spacing;

    for (let x = 0; x < canvas.width; x += 5) {
      const offset = noise(x + frame * 0.5 + i * 10) * 30;
      const y = baseY + offset;

      if (x === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }

    ctx.stroke();
  }
}
```

### Variation 3: Recursive Tree

```javascript
function drawTree(x, y, length, angle, depth) {
  if (depth === 0) return;

  // Calculate end point
  const endX = x + Math.cos(angle) * length;
  const endY = y + Math.sin(angle) * length;

  // Draw branch
  ctx.strokeStyle = `hsl(${depth * 30}, 60%, 40%)`;
  ctx.lineWidth = depth;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Recursive branches
  drawTree(endX, endY, length * 0.7, angle - 0.4, depth - 1);
  drawTree(endX, endY, length * 0.7, angle + 0.4, depth - 1);
}

// Usage
function drawPattern() {
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const baseAngle = -Math.PI / 2 + Math.sin(frame * 0.01) * 0.2;
  drawTree(canvas.width / 2, canvas.height, 100, baseAngle, 10);
}
```

---

## Step 9: Debugging & Optimization

### Common Issues

**1. Animation too slow:**

- Reduce number of shapes
- Simplify calculations
- Use `ctx.clearRect()` instead of semi-transparent fills

**2. Flickering:**

- Ensure consistent frame rate
- Don't clear canvas inside loops

**3. Memory leaks:**

- Don't create new particles every frame
- Reuse objects when possible

### Performance Tips

```javascript
// Bad: Creates new objects every frame
function drawPattern() {
  const particles = [];
  for (let i = 0; i < 100; i++) {
    particles.push(new Particle());
  }
  particles.forEach((p) => p.draw());
}

// Good: Reuse particles array
let particles = [];
function initParticles() {
  particles = [];
  for (let i = 0; i < 100; i++) {
    particles.push(new Particle());
  }
}
initParticles();

function drawPattern() {
  particles.forEach((p) => {
    p.update();
    p.draw();
  });
}
```

**Measure Performance:**

```javascript
function animate() {
  const startTime = performance.now();

  // Drawing code
  drawPattern();

  const endTime = performance.now();
  const frameTime = endTime - startTime;

  if (frameTime > 16.67) {
    // 60 FPS = 16.67ms per frame
    console.warn(`Slow frame: ${frameTime.toFixed(2)}ms`);
  }

  requestAnimationFrame(animate);
}
```

---

## Step 10: Reflection & Exploration

### Creative Prompts

1. **Nature-inspired:** Create organic patterns (leaves, waves, cells)
2. **Geometric:** Explore tessellations, Islamic patterns, mandalas
3. **Abstract:** Combine random shapes, colors, movements
4. **Data-driven:** Use external data to drive visual parameters

### Questions to Consider

- How do parameters affect the emergent pattern?
- What balance of randomness vs. order creates interesting visuals?
- How does color palette impact mood?
- What would happen if you combined two algorithms?

### Sharing & Critique

**When presenting your work:**

- Explain the algorithm and parameters
- Show variations (different settings)
- Discuss creative decisions (color, composition)
- Invite feedback and suggestions

**When reviewing peers' work:**

- Identify interesting emergent patterns
- Suggest parameter variations to try
- Discuss technical implementation
- Appreciate unique creative choices

---

## Summary

**You've learned:**

- **Animation loops** with `requestAnimationFrame()`
- **Random generation** for visual variety
- **Parameterization** for controllable art
- **Canvas transformations** (translate, rotate, scale)
- **UI controls** linked to visual parameters
- **Algorithmic patterns** (spirograph, particles, recursion)
- **Creative coding** mindset

**Key Concepts:**

- Generative art combines **rules, randomness, and repetition**
- **Parameters** make art interactive and explorable
- **Emergent complexity** from simple algorithms
- **Code as creative medium**

**Next Steps:**

- Experiment with different algorithms
- Create your own unique pattern
- Combine techniques (particles + geometry + noise)
- Explore libraries like p5.js, Three.js for advanced creative coding

---

## Resources

**Creative Coding Frameworks:**

- [p5.js](https://p5js.org/) — JavaScript library inspired by Processing
- [Processing](https://processing.org/) — Visual arts programming language
- [three.js](https://threejs.org/) — 3D graphics library

**Tutorials & Inspiration:**

- [The Coding Train (YouTube)](https://www.youtube.com/c/TheCodingTrain) — Dan Shiffman's creative coding tutorials
- [OpenProcessing](https://openprocessing.org/) — Community of creative coders
- [Chrome Experiments](https://experiments.withgoogle.com/) — Interactive web experiments

**Generative Art Resources:**

- [Generative Artistry](https://generativeartistry.com/) — Tutorials on generative art algorithms
- [Tyler Hobbs](https://tylerxhobbs.com/) — Generative artist, blog posts on techniques

**Books:**

- _Generative Design_ by Hartmut Bohnacker et al.
- _The Nature of Code_ by Daniel Shiffman (free online)

---

**Happy Creating!**

<!-- End of Tutorial: Unit 6.1 -->
